"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = writeXlsxFile;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _os = _interopRequireDefault(require("os"));

var _archive = _interopRequireDefault(require("./archive.js"));

var _workbookXml = _interopRequireDefault(require("./statics/workbook.xml.js"));

var _workbookXmlRels = _interopRequireDefault(require("./statics/workbook.xml.rels.js"));

var _rels2 = _interopRequireDefault(require("./statics/rels.js"));

var _Content_TypesXml = _interopRequireDefault(require("./statics/[Content_Types].xml.js"));

var _writeXlsxFileCommon = require("./writeXlsxFile.common.js");

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function writeXlsxFile(_x) {
  return _writeXlsxFile.apply(this, arguments);
}

function _writeXlsxFile() {
  _writeXlsxFile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(data) {
    var _ref,
        filePath,
        buffer,
        sheetName,
        sheetNames,
        schema,
        columns,
        headerStyle,
        fontFamily,
        fontSize,
        orientation,
        stickyRowsCount,
        stickyColumnsCount,
        dateFormat,
        archive,
        _generateSheets,
        sheets,
        getSharedStringsXml,
        getStylesXml,
        root,
        xl,
        _rels,
        worksheetsPath,
        promises,
        _iterator2,
        _step2,
        _step2$value,
        id,
        _data,
        _args = arguments;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, filePath = _ref.filePath, buffer = _ref.buffer, sheetName = _ref.sheet, sheetNames = _ref.sheets, schema = _ref.schema, columns = _ref.columns, headerStyle = _ref.headerStyle, fontFamily = _ref.fontFamily, fontSize = _ref.fontSize, orientation = _ref.orientation, stickyRowsCount = _ref.stickyRowsCount, stickyColumnsCount = _ref.stickyColumnsCount, dateFormat = _ref.dateFormat;
            archive = new _archive["default"](filePath);
            _generateSheets = (0, _writeXlsxFileCommon.generateSheets)({
              data: data,
              sheetName: sheetName,
              sheetNames: sheetNames,
              schema: schema,
              columns: columns,
              headerStyle: headerStyle,
              fontFamily: fontFamily,
              fontSize: fontSize,
              orientation: orientation,
              stickyRowsCount: stickyRowsCount,
              stickyColumnsCount: stickyColumnsCount,
              dateFormat: dateFormat
            }), sheets = _generateSheets.sheets, getSharedStringsXml = _generateSheets.getSharedStringsXml, getStylesXml = _generateSheets.getStylesXml; // There doesn't seem to be a way to just append a file into a subdirectory
            // in `archiver` library, hence using a hacky temporary directory workaround.
            // https://www.npmjs.com/package/archiver

            _context.next = 5;
            return createTempDirectory();

          case 5:
            root = _context.sent;
            _context.next = 8;
            return createDirectory(_path["default"].join(root, 'xl'));

          case 8:
            xl = _context.sent;
            _context.next = 11;
            return createDirectory(_path["default"].join(xl, '_rels'));

          case 11:
            _rels = _context.sent;
            _context.next = 14;
            return createDirectory(_path["default"].join(xl, 'worksheets'));

          case 14:
            worksheetsPath = _context.sent;
            promises = [writeFile(_path["default"].join(_rels, 'workbook.xml.rels'), (0, _workbookXmlRels["default"])({
              sheets: sheets
            })), writeFile(_path["default"].join(xl, 'workbook.xml'), (0, _workbookXml["default"])({
              sheets: sheets,
              stickyRowsCount: stickyRowsCount,
              stickyColumnsCount: stickyColumnsCount
            })), writeFile(_path["default"].join(xl, 'styles.xml'), getStylesXml()), writeFile(_path["default"].join(xl, 'sharedStrings.xml'), getSharedStringsXml())];

            for (_iterator2 = _createForOfIteratorHelperLoose(sheets); !(_step2 = _iterator2()).done;) {
              _step2$value = _step2.value, id = _step2$value.id, _data = _step2$value.data;
              promises.push(writeFile(_path["default"].join(worksheetsPath, "sheet".concat(id, ".xml")), _data));
            }

            _context.next = 19;
            return Promise.all(promises);

          case 19:
            archive.directory(xl, 'xl');
            archive.append(_rels2["default"], '_rels/.rels');
            archive.append(_Content_TypesXml["default"], '[Content_Types].xml');

            if (!filePath) {
              _context.next = 29;
              break;
            }

            _context.next = 25;
            return archive.write();

          case 25:
            _context.next = 27;
            return removeDirectoryWithLegacyNodeVersionsSupport(root);

          case 27:
            _context.next = 34;
            break;

          case 29:
            if (!buffer) {
              _context.next = 33;
              break;
            }

            return _context.abrupt("return", streamToBuffer(archive.write()));

          case 33:
            return _context.abrupt("return", archive.write());

          case 34:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _writeXlsxFile.apply(this, arguments);
}

function writeFile(path, contents) {
  return new Promise(function (resolve, reject) {
    _fs["default"].writeFile(path, contents, 'utf-8', function (error) {
      if (error) {
        return reject(error);
      }

      resolve();
    });
  });
}

function createDirectory(path) {
  return new Promise(function (resolve, reject) {
    _fs["default"].mkdir(path, function (error) {
      if (error) {
        return reject(error);
      }

      resolve(path);
    });
  });
}

function createTempDirectory() {
  return new Promise(function (resolve, reject) {
    _fs["default"].mkdtemp(_path["default"].join(_os["default"].tmpdir(), 'write-excel-file-'), function (error, directoryPath) {
      if (error) {
        return reject(error);
      }

      resolve(directoryPath);
    });
  });
}

function removeDirectoryWithLegacyNodeVersionsSupport(path) {
  if (_fs["default"].rm) {
    return removeDirectory(path);
  } else {
    removeDirectoryLegacySync(path);
    return Promise.resolve();
  }
} // `fs.rm()` is available in Node.js since `14.14.0`.


function removeDirectory(path) {
  return new Promise(function (resolve, reject) {
    _fs["default"].rm(path, {
      recursive: true,
      force: true
    }, function (error) {
      if (error) {
        return reject(error);
      }

      resolve();
    });
  });
} // For Node.js versions below `14.14.0`.


function removeDirectoryLegacySync(directoryPath) {
  var childNames = _fs["default"].readdirSync(directoryPath);

  for (var _iterator = _createForOfIteratorHelperLoose(childNames), _step; !(_step = _iterator()).done;) {
    var childName = _step.value;

    var childPath = _path["default"].join(directoryPath, childName);

    var stats = _fs["default"].statSync(childPath);

    if (childPath === '.' || childPath === '..') {// Skip.
    } else if (stats.isDirectory()) {
      // Remove subdirectory recursively.
      removeDirectoryLegacySync(childPath);
    } else {
      // Remove file.
      _fs["default"].unlinkSync(childPath);
    }
  }

  _fs["default"].rmdirSync(directoryPath);
} // https://stackoverflow.com/a/67729663


function streamToBuffer(stream) {
  return new Promise(function (resolve, reject) {
    var chunks = [];
    stream.on('data', function (chunk) {
      return chunks.push(chunk);
    });
    stream.on('end', function () {
      return resolve(Buffer.concat(chunks));
    });
    stream.on('error', reject);
  });
}
//# sourceMappingURL=writeXlsxFileNode.js.map