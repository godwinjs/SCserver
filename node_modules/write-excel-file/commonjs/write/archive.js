"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _archiver = _interopRequireDefault(require("archiver"));

var _fs = _interopRequireDefault(require("fs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * A server-side *.zip archive creator.
 */
var Archive = /*#__PURE__*/function () {
  function Archive(outputPath) {
    _classCallCheck(this, Archive);

    var output;

    if (outputPath) {
      output = _fs["default"].createWriteStream(outputPath);
    } else {// // Won't work for memory streams.
      // // https://github.com/archiverjs/node-archiver/issues/336
      // output = new WritableStream()
    }

    var archive = (0, _archiver["default"])('zip', {// // Sets the compression level.
      // zlib: { level: 9 }
    });
    this.archive = archive;

    if (output) {
      this.promise = new Promise(function (resolve, reject) {
        // listen for all archive data to be written
        // 'close' event is fired only when a file descriptor is involved
        output.on('close', function () {
          return resolve({
            size: archive.pointer()
          });
        }); // // This event is fired when the data source is drained no matter what was the data source.
        // // It is not part of this library but rather from the NodeJS Stream API.
        // // @see: https://nodejs.org/api/stream.html#stream_event_end
        // archive.on('end', function() {
        //   console.log('Data has been drained')
        //   resolve({
        //     // output: outputPath ? undefined : output.toBuffer(),
        //     size: archive.pointer()
        //   })
        // })
        // good practice to catch warnings (ie stat failures and other non-blocking errors)

        archive.on('warning', function (error) {
          if (error.code === 'ENOENT') {
            // log warning
            console.warn(error);
          } else {
            reject(error);
          }
        }); // good practice to catch this error explicitly

        archive.on('error', reject); // pipe archive data to the file

        archive.pipe(output);
      });
    }
  }

  _createClass(Archive, [{
    key: "file",
    value: function file(filePath, internalPath) {
      this.archive.file(filePath, {
        name: internalPath
      });
    }
  }, {
    key: "directory",
    value: function directory(directoryPath, internalPath) {
      this.archive.directory(directoryPath, internalPath);
    }
  }, {
    key: "append",
    value: function append(content, internalPath) {
      this.archive.append(content, {
        name: internalPath
      });
    }
  }, {
    key: "write",
    value: function write() {
      // Maybe `.finalize()` itself returns some `Promise`.
      this.archive.finalize();
      return this.promise || this.archive;
    }
  }]);

  return Archive;
}();

exports["default"] = Archive;
//# sourceMappingURL=archive.js.map