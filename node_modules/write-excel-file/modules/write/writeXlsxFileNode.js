import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import fs from 'fs';
import path from 'path';
import os from 'os';
import Archive from './archive.js';
import generateWorkbookXml from './statics/workbook.xml.js';
import generateWorkbookXmlRels from './statics/workbook.xml.rels.js';
import rels from './statics/rels.js';
import contentTypes from './statics/[Content_Types].xml.js';
import { generateSheets } from './writeXlsxFile.common.js';
export default function writeXlsxFile(_x) {
  return _writeXlsxFile.apply(this, arguments);
}

function _writeXlsxFile() {
  _writeXlsxFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {
    var _ref,
        filePath,
        buffer,
        sheetName,
        sheetNames,
        schema,
        columns,
        headerStyle,
        fontFamily,
        fontSize,
        orientation,
        stickyRowsCount,
        stickyColumnsCount,
        dateFormat,
        archive,
        _generateSheets,
        sheets,
        getSharedStringsXml,
        getStylesXml,
        root,
        xl,
        _rels,
        worksheetsPath,
        promises,
        _iterator2,
        _step2,
        _step2$value,
        id,
        _data,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, filePath = _ref.filePath, buffer = _ref.buffer, sheetName = _ref.sheet, sheetNames = _ref.sheets, schema = _ref.schema, columns = _ref.columns, headerStyle = _ref.headerStyle, fontFamily = _ref.fontFamily, fontSize = _ref.fontSize, orientation = _ref.orientation, stickyRowsCount = _ref.stickyRowsCount, stickyColumnsCount = _ref.stickyColumnsCount, dateFormat = _ref.dateFormat;
            archive = new Archive(filePath);
            _generateSheets = generateSheets({
              data: data,
              sheetName: sheetName,
              sheetNames: sheetNames,
              schema: schema,
              columns: columns,
              headerStyle: headerStyle,
              fontFamily: fontFamily,
              fontSize: fontSize,
              orientation: orientation,
              stickyRowsCount: stickyRowsCount,
              stickyColumnsCount: stickyColumnsCount,
              dateFormat: dateFormat
            }), sheets = _generateSheets.sheets, getSharedStringsXml = _generateSheets.getSharedStringsXml, getStylesXml = _generateSheets.getStylesXml; // There doesn't seem to be a way to just append a file into a subdirectory
            // in `archiver` library, hence using a hacky temporary directory workaround.
            // https://www.npmjs.com/package/archiver

            _context.next = 5;
            return createTempDirectory();

          case 5:
            root = _context.sent;
            _context.next = 8;
            return createDirectory(path.join(root, 'xl'));

          case 8:
            xl = _context.sent;
            _context.next = 11;
            return createDirectory(path.join(xl, '_rels'));

          case 11:
            _rels = _context.sent;
            _context.next = 14;
            return createDirectory(path.join(xl, 'worksheets'));

          case 14:
            worksheetsPath = _context.sent;
            promises = [writeFile(path.join(_rels, 'workbook.xml.rels'), generateWorkbookXmlRels({
              sheets: sheets
            })), writeFile(path.join(xl, 'workbook.xml'), generateWorkbookXml({
              sheets: sheets,
              stickyRowsCount: stickyRowsCount,
              stickyColumnsCount: stickyColumnsCount
            })), writeFile(path.join(xl, 'styles.xml'), getStylesXml()), writeFile(path.join(xl, 'sharedStrings.xml'), getSharedStringsXml())];

            for (_iterator2 = _createForOfIteratorHelperLoose(sheets); !(_step2 = _iterator2()).done;) {
              _step2$value = _step2.value, id = _step2$value.id, _data = _step2$value.data;
              promises.push(writeFile(path.join(worksheetsPath, "sheet".concat(id, ".xml")), _data));
            }

            _context.next = 19;
            return Promise.all(promises);

          case 19:
            archive.directory(xl, 'xl');
            archive.append(rels, '_rels/.rels');
            archive.append(contentTypes, '[Content_Types].xml');

            if (!filePath) {
              _context.next = 29;
              break;
            }

            _context.next = 25;
            return archive.write();

          case 25:
            _context.next = 27;
            return removeDirectoryWithLegacyNodeVersionsSupport(root);

          case 27:
            _context.next = 34;
            break;

          case 29:
            if (!buffer) {
              _context.next = 33;
              break;
            }

            return _context.abrupt("return", streamToBuffer(archive.write()));

          case 33:
            return _context.abrupt("return", archive.write());

          case 34:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _writeXlsxFile.apply(this, arguments);
}

function writeFile(path, contents) {
  return new Promise(function (resolve, reject) {
    fs.writeFile(path, contents, 'utf-8', function (error) {
      if (error) {
        return reject(error);
      }

      resolve();
    });
  });
}

function createDirectory(path) {
  return new Promise(function (resolve, reject) {
    fs.mkdir(path, function (error) {
      if (error) {
        return reject(error);
      }

      resolve(path);
    });
  });
}

function createTempDirectory() {
  return new Promise(function (resolve, reject) {
    fs.mkdtemp(path.join(os.tmpdir(), 'write-excel-file-'), function (error, directoryPath) {
      if (error) {
        return reject(error);
      }

      resolve(directoryPath);
    });
  });
}

function removeDirectoryWithLegacyNodeVersionsSupport(path) {
  if (fs.rm) {
    return removeDirectory(path);
  } else {
    removeDirectoryLegacySync(path);
    return Promise.resolve();
  }
} // `fs.rm()` is available in Node.js since `14.14.0`.


function removeDirectory(path) {
  return new Promise(function (resolve, reject) {
    fs.rm(path, {
      recursive: true,
      force: true
    }, function (error) {
      if (error) {
        return reject(error);
      }

      resolve();
    });
  });
} // For Node.js versions below `14.14.0`.


function removeDirectoryLegacySync(directoryPath) {
  var childNames = fs.readdirSync(directoryPath);

  for (var _iterator = _createForOfIteratorHelperLoose(childNames), _step; !(_step = _iterator()).done;) {
    var childName = _step.value;
    var childPath = path.join(directoryPath, childName);
    var stats = fs.statSync(childPath);

    if (childPath === '.' || childPath === '..') {// Skip.
    } else if (stats.isDirectory()) {
      // Remove subdirectory recursively.
      removeDirectoryLegacySync(childPath);
    } else {
      // Remove file.
      fs.unlinkSync(childPath);
    }
  }

  fs.rmdirSync(directoryPath);
} // https://stackoverflow.com/a/67729663


function streamToBuffer(stream) {
  return new Promise(function (resolve, reject) {
    var chunks = [];
    stream.on('data', function (chunk) {
      return chunks.push(chunk);
    });
    stream.on('end', function () {
      return resolve(Buffer.concat(chunks));
    });
    stream.on('error', reject);
  });
}
//# sourceMappingURL=writeXlsxFileNode.js.map